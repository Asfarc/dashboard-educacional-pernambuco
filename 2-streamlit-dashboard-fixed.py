import streamlit as st
import pandas as pd
import plotly.express as px
import numpy as np
import os
from pathlib import Path
import io

# -------------------------------
# ConfiguraÃ§Ã£o Inicial da PÃ¡gina
# -------------------------------
st.set_page_config(
    page_title="Dashboard PNE",
    page_icon="ðŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# -------------------------------
# FunÃ§Ãµes Auxiliares
# -------------------------------

def formatar_numero(numero):
    """
    Formata nÃºmeros grandes adicionando separadores de milhar.
    Se o nÃºmero for NaN ou '-', retorna '-'.
    """
    if pd.isna(numero) or numero == "-":
        return "-"
    return f"{int(numero):,}".replace(",", ".")

def carregar_dados():
    """
    Carrega os dados das planilhas no formato Parquet.
    - LÃª os arquivos: escolas.parquet, estado.parquet e municipio.parquet.
    - Converte colunas que comeÃ§am com 'NÃºmero de' para tipo numÃ©rico.
    Em caso de erro, exibe uma mensagem e interrompe a execuÃ§Ã£o.
    """
    try:
        # Carregar os trÃªs arquivos Parquet
        escolas_df = pd.read_parquet("escolas.parquet")
        estado_df = pd.read_parquet("estado.parquet")
        municipio_df = pd.read_parquet("municipio.parquet")
        
        # Converter colunas numÃ©ricas para o tipo correto
        for df in [escolas_df, estado_df, municipio_df]:
            for col in df.columns:
                if col.startswith("NÃºmero de"):
                    df[col] = pd.to_numeric(df[col], errors='coerce')
        
        return escolas_df, estado_df, municipio_df
    
    except Exception as e:
        st.error(f"Erro ao carregar os dados: {e}")
        st.info("Verifique se os arquivos Parquet estÃ£o disponÃ­veis no repositÃ³rio.")
        st.stop()

def criar_mapeamento_colunas(df):
    """
    Cria um dicionÃ¡rio que mapeia as etapas de ensino para os nomes das colunas.
    Esse mapeamento inclui a coluna principal, subetapas e sÃ©ries, facilitando a seleÃ§Ã£o
    dos dados conforme os filtros do usuÃ¡rio.
    
    ParÃ¢metros:
    df (DataFrame): DataFrame a ser usado como referÃªncia para verificar colunas existentes
    """
    # Cria um dicionÃ¡rio de correspondÃªncia insensÃ­vel a maiÃºsculas/minÃºsculas
    colunas_map = {col.lower().strip(): col for col in df.columns}
    
    # FunÃ§Ã£o auxiliar para verificar e obter o nome correto da coluna
    def obter_coluna_real(nome_padrao):
        # Verifica se a coluna existe exatamente como foi especificada
        if nome_padrao in df.columns:
            return nome_padrao
            
        # Verifica se existe uma versÃ£o case-insensitive da coluna
        nome_normalizado = nome_padrao.lower().strip()
        if nome_normalizado in colunas_map:
            return colunas_map[nome_normalizado]
            
        # Se nÃ£o encontrar, retorna o nome original
        return nome_padrao
    
    mapeamento = {
        "EducaÃ§Ã£o Infantil": {
            "coluna_principal": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o Infantil"),
            "subetapas": {
                "Creche": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o Infantil - Creche"),
                "PrÃ©-Escola": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o Infantil - PrÃ©-Escola")
            },
            "series": {}
        },
        "Ensino Fundamental": {
            "coluna_principal": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental"),
            "subetapas": {
                "Anos Iniciais": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Iniciais"),
                "Anos Finais": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Finais")
            },
            "series": {
                "Anos Iniciais": {
                    "1Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Iniciais - 1Âº Ano"),
                    "2Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Iniciais - 2Âº Ano"),
                    "3Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Iniciais - 3Âº Ano"),
                    "4Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Iniciais - 4Âº Ano"),
                    "5Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Iniciais - 5Âº Ano")
                },
                "Anos Finais": {
                    "6Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Finais - 6Âº Ano"),
                    "7Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Finais - 7Âº Ano"),
                    "8Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Finais - 8Âº Ano"),
                    "9Âº Ano": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino Fundamental - Anos Finais - 9Âº Ano")
                }
            }
        },
        "Ensino MÃ©dio": {
            "coluna_principal": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio"),
            "subetapas": {
                "PropedÃªutico": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - PropedÃªutico"),
                "Curso TÃ©cnico Integrado": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Curso TÃ©cnico Integrado Ã  EducaÃ§Ã£o Profissional"),
                "Normal/MagistÃ©rio": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Modalidade Normal/MagistÃ©rio")
            },
            "series": {
                "PropedÃªutico": {
                    "1Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - PropedÃªutico - 1Âº ano/1Âª SÃ©rie"),
                    "2Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - PropedÃªutico - 2Âº ano/2Âª SÃ©rie"),
                    "3Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - PropedÃªutico - 3Âº ano/3Âª SÃ©rie"),
                    "4Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - PropedÃªutico - 4Âº ano/4Âª SÃ©rie"),
                    "NÃ£o Seriado": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - PropedÃªutico - NÃ£o Seriado")
                },
                "Curso TÃ©cnico Integrado": {
                    "1Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Curso TÃ©cnico Integrado Ã  EducaÃ§Ã£o Profissional - 1Âº ano/1Âª SÃ©rie"),
                    "2Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Curso TÃ©cnico Integrado Ã  EducaÃ§Ã£o Profissional - 2Âº ano/2Âª SÃ©rie"),
                    "3Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Curso TÃ©cnico Integrado Ã  EducaÃ§Ã£o Profissional - 3Âº ano/3Âª SÃ©rie"),
                    "4Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Curso TÃ©cnico Integrado Ã  EducaÃ§Ã£o Profissional - 4Âº ano/4Âª SÃ©rie"),
                    "NÃ£o Seriado": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Curso TÃ©cnico Integrado Ã  EducaÃ§Ã£o Profissional - NÃ£o Seriado")
                },
                "Normal/MagistÃ©rio": {
                    "1Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Modalidade Normal/MagistÃ©rio - 1Âº ano/1Âª SÃ©rie"),
                    "2Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Modalidade Normal/MagistÃ©rio - 2Âº ano/2Âª SÃ©rie"),
                    "3Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Modalidade Normal/MagistÃ©rio - 3Âº ano/3Âª SÃ©rie"),
                    "4Âª SÃ©rie": obter_coluna_real("NÃºmero de MatrÃ­culas do Ensino MÃ©dio - Modalidade Normal/MagistÃ©rio - 4Âº ano/4Âª SÃ©rie")
                }
            }
        },
        "EJA": {
            "coluna_principal": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o de Jovens e Adultos (EJA)"),
            "subetapas": {
                "Ensino Fundamental": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o de Jovens e Adultos (EJA) - Ensino Fundamental"),
                "Ensino MÃ©dio": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o de Jovens e Adultos (EJA) - Ensino MÃ©dio")
            },
            "series": {
                "Ensino Fundamental": {
                    "Anos Iniciais": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o de Jovens e Adultos (EJA) - Ensino Fundamental - Anos Iniciais"),
                    "Anos Finais": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o de Jovens e Adultos (EJA) - Ensino Fundamental - Anos Finais")
                }
            }
        },
        "EducaÃ§Ã£o Profissional": {
            "coluna_principal": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o Profissional"),
            "subetapas": {
                "TÃ©cnica": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o Profissional TÃ©cnica"),
                "Curso FIC": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o Profissional - Curso FIC Concomitante")
            },
            "series": {
                "TÃ©cnica": {
                    "Concomitante": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o Profissional TÃ©cnica - Curso TÃ©cnico Concomitante"),
                    "Subsequente": obter_coluna_real("NÃºmero de MatrÃ­culas da EducaÃ§Ã£o Profissional TÃ©cnica - Curso TÃ©cnico Subsequente")
                }
            }
        }
    }
    
    return mapeamento

# -------------------------------
# Carregamento de Dados
# -------------------------------
try:
    escolas_df, estado_df, municipio_df = carregar_dados()
except Exception as e:
    st.error(f"Erro ao carregar os dados: {e}")
    st.stop()

# Primeira seleÃ§Ã£o do DataFrame
tipo_visualizacao = "Estado"  # Valor padrÃ£o
df = estado_df  # DataFrame padrÃ£o para iniciar

# Agora crie o mapeamento de colunas usando o DataFrame inicial
mapeamento_colunas = criar_mapeamento_colunas(df)

# ======================================
# CONFIGURAÃ‡ÃƒO DA BARRA LATERAL (FILTROS)
# ======================================

st.sidebar.title("Filtros")

# SeleÃ§Ã£o do nÃ­vel de agregaÃ§Ã£o
tipo_visualizacao = st.sidebar.radio(
    "NÃ­vel de AgregaÃ§Ã£o:",
    ["Escola", "MunicÃ­pio", "Estado"]
)

# SeleÃ§Ã£o do DataFrame conforme o nÃ­vel escolhido
if tipo_visualizacao == "Escola":
    df = escolas_df
elif tipo_visualizacao == "MunicÃ­pio":
    df = municipio_df
else:
    df = estado_df

# Filtro do Ano
if "ANO" in df.columns:
    anos_disponiveis = sorted(df["ANO"].unique())
    ano_selecionado = st.sidebar.selectbox("Ano do Censo:", anos_disponiveis)
    df_filtrado = df[df["ANO"] == ano_selecionado]
else:
    st.error("A coluna 'ANO' nÃ£o foi encontrada nos dados carregados.")
    st.stop()

# Filtro da DEPENDENCIA ADMINISTRATIVA
if "DEPENDENCIA ADMINISTRATIVA" in df.columns:
    dependencias_disponiveis = sorted(df["DEPENDENCIA ADMINISTRATIVA"].unique())
    dependencia_selecionada = st.sidebar.multiselect(
        "DEPENDENCIA ADMINISTRATIVA:",
        dependencias_disponiveis,
        default=dependencias_disponiveis
    )
    if dependencia_selecionada:
        df_filtrado = df_filtrado[df_filtrado["DEPENDENCIA ADMINISTRATIVA"].isin(dependencia_selecionada)]
else:
    st.warning("A coluna 'DEPENDENCIA ADMINISTRATIVA' nÃ£o foi encontrada nos dados carregados.")

# Filtro da Etapa de Ensino
etapas_disponiveis = list(mapeamento_colunas.keys())
etapa_selecionada = st.sidebar.selectbox(
    "Etapa de Ensino:",
    etapas_disponiveis
)

# VerificaÃ§Ã£o se a etapa estÃ¡ no mapeamento
if etapa_selecionada not in mapeamento_colunas:
    st.error(f"A etapa '{etapa_selecionada}' nÃ£o foi encontrada no mapeamento de colunas.")
    st.stop()

# Filtro da Subetapa (varia de acordo com a etapa selecionada)
if "subetapas" in mapeamento_colunas[etapa_selecionada] and mapeamento_colunas[etapa_selecionada]["subetapas"]:
    subetapas_disponiveis = list(mapeamento_colunas[etapa_selecionada]["subetapas"].keys())
    subetapa_selecionada = st.sidebar.selectbox(
        "Subetapa:",
        ["Todas"] + subetapas_disponiveis
    )
else:
    subetapa_selecionada = "Todas"

# Filtro para a SÃ©rie, se aplicÃ¡vel Ã  subetapa selecionada
series_disponiveis = []
if (subetapa_selecionada != "Todas" and 
    "series" in mapeamento_colunas[etapa_selecionada] and 
    subetapa_selecionada in mapeamento_colunas[etapa_selecionada]["series"]):
    series_disponiveis = list(mapeamento_colunas[etapa_selecionada]["series"][subetapa_selecionada].keys())
    serie_selecionada = st.sidebar.selectbox(
        "SÃ©rie:",
        ["Todas"] + series_disponiveis
    )
else:
    serie_selecionada = "Todas"

# -------------------------------
# DeterminaÃ§Ã£o da Coluna de Dados
# -------------------------------
try:
    if subetapa_selecionada == "Todas":
        # Se nenhuma subetapa for selecionada, use a coluna principal da etapa
        coluna_dados = mapeamento_colunas[etapa_selecionada]["coluna_principal"]
    elif serie_selecionada == "Todas" or "series" not in mapeamento_colunas[etapa_selecionada] or subetapa_selecionada not in mapeamento_colunas[etapa_selecionada].get("series", {}):
        # Se nenhuma sÃ©rie for selecionada ou a subetapa nÃ£o tiver sÃ©ries, use a coluna da subetapa
        coluna_dados = mapeamento_colunas[etapa_selecionada]["subetapas"][subetapa_selecionada]
    else:
        # Se uma sÃ©rie especÃ­fica for selecionada, verifique se ela existe
        if serie_selecionada in mapeamento_colunas[etapa_selecionada]["series"][subetapa_selecionada]:
            coluna_dados = mapeamento_colunas[etapa_selecionada]["series"][subetapa_selecionada][serie_selecionada]
        else:
            # Caso contrÃ¡rio, use a coluna da subetapa
            coluna_dados = mapeamento_colunas[etapa_selecionada]["subetapas"][subetapa_selecionada]
except KeyError as e:
    st.error(f"Erro ao acessar as informaÃ§Ãµes de mapeamento: {e}")
    # Fallback para a coluna principal se houver erro
    coluna_dados = mapeamento_colunas[etapa_selecionada].get("coluna_principal", "")

# -------------------------------
# CabeÃ§alho e InformaÃ§Ãµes Iniciais do Dashboard
# -------------------------------
st.title("Dashboard de MatrÃ­culas - Inep")
st.markdown(f"**VisualizaÃ§Ã£o por {tipo_visualizacao} - Ano: {ano_selecionado}**")

# ExibiÃ§Ã£o dos filtros selecionados
filtro_texto = f"**Etapa:** {etapa_selecionada}"
if subetapa_selecionada != "Todas":
    filtro_texto += f" | **Subetapa:** {subetapa_selecionada}"
    if serie_selecionada != "Todas" and serie_selecionada in series_disponiveis:
        filtro_texto += f" | **SÃ©rie:** {serie_selecionada}"
st.markdown(filtro_texto)

# Verifica se a coluna de dados existe; se nÃ£o, tenta encontrar uma coluna similar
if coluna_dados not in df_filtrado.columns:
    # Tenta verificar se hÃ¡ uma versÃ£o case-insensitive da coluna
    coluna_normalizada = coluna_dados.lower().strip()
    colunas_normalizadas = {col.lower().strip(): col for col in df_filtrado.columns}
    
    if coluna_normalizada in colunas_normalizadas:
        coluna_dados_original = coluna_dados
        coluna_dados = colunas_normalizadas[coluna_normalizada]
        st.info(f"Usando coluna '{coluna_dados}' em vez de '{coluna_dados_original}'")
    else:
        st.warning(f"A coluna {coluna_dados} nÃ£o estÃ¡ disponÃ­vel nos dados.")
        coluna_dados = mapeamento_colunas[etapa_selecionada]["coluna_principal"]
        if coluna_dados not in df_filtrado.columns:
            st.error("NÃ£o foi possÃ­vel encontrar dados para a etapa selecionada.")
            st.stop()

# -------------------------------
# SeÃ§Ã£o de Indicadores (KPIs)
# -------------------------------
col1, col2, col3 = st.columns(3)

# KPI 1: Total de MatrÃ­culas na etapa/subetapa/sÃ©rie selecionada
total_matriculas = df_filtrado[coluna_dados].sum()
with col1:
    st.metric("Total de MatrÃ­culas", formatar_numero(total_matriculas))

# KPI 2: MÃ©dia de MatrÃ­culas
with col2:
    if tipo_visualizacao == "Escola":
        if len(df_filtrado) > 0:
            media_por_escola = df_filtrado[coluna_dados].mean()
            st.metric("MÃ©dia de MatrÃ­culas por Escola", formatar_numero(media_por_escola))
        else:
            st.metric("MÃ©dia de MatrÃ­culas por Escola", "-")
    else:
        media_por_dependencia = df_filtrado.groupby("DEPENDENCIA ADMINISTRATIVA")[coluna_dados].mean()
        if not media_por_dependencia.empty:
            media_geral = media_por_dependencia.mean()
            st.metric("MÃ©dia de MatrÃ­culas", formatar_numero(media_geral))
        else:
            st.metric("MÃ©dia de MatrÃ­culas", "-")

# KPI 3: Indicador adicional conforme a visualizaÃ§Ã£o
with col3:
    if tipo_visualizacao == "Escola":
        total_escolas = len(df_filtrado)
        st.metric("Total de Escolas", formatar_numero(total_escolas))
    elif tipo_visualizacao == "MunicÃ­pio":
        total_municipios = len(df_filtrado)
        st.metric("Total de MunicÃ­pios", formatar_numero(total_municipios))
    else:
        st.metric("MÃ¡ximo de MatrÃ­culas", formatar_numero(df_filtrado[coluna_dados].max()))

# -------------------------------
# SeÃ§Ã£o de GrÃ¡ficos
# -------------------------------
st.markdown("## AnÃ¡lise GrÃ¡fica")

# GrÃ¡fico 1: DistribuiÃ§Ã£o de MatrÃ­culas por DEPENDENCIA ADMINISTRATIVA (GrÃ¡fico de Pizza)
if "DEPENDENCIA ADMINISTRATIVA" in df_filtrado.columns:
    fig1 = px.pie(
        df_filtrado, 
        names="DEPENDENCIA ADMINISTRATIVA", 
        values=coluna_dados,
        title="DistribuiÃ§Ã£o de MatrÃ­culas por DEPENDENCIA ADMINISTRATIVA",
        color_discrete_sequence=px.colors.qualitative.Set3
    )
    st.plotly_chart(fig1, use_container_width=True)
else:
    st.warning("NÃ£o foi possÃ­vel criar o grÃ¡fico de distribuiÃ§Ã£o por DEPENDENCIA ADMINISTRATIVA")

# -------------------------------
# SeÃ§Ã£o de Tabela de Dados Detalhados
# -------------------------------
st.markdown("## Dados Detalhados")

# SeleÃ§Ã£o das colunas a serem exibidas na tabela, conforme o nÃ­vel de visualizaÃ§Ã£o
if tipo_visualizacao == "Escola":
    colunas_tabela = ["CODIGO DA ESCOLA", "NOME DA ESCOLA", "CODIGO DO MUNICIPIO", "NOME DO MUNICIPIO", "CODIGO DA UF", "NOME DA UF", "DEPENDENCIA ADMINISTRATIVA"]
elif tipo_visualizacao == "MunicÃ­pio":
    colunas_tabela = ["CODIGO DO MUNICIPIO", "NOME DO MUNICIPIO", "CODIGO DA UF", "NOME DA UF", "DEPENDENCIA ADMINISTRATIVA"]
else:  # Estado
    colunas_tabela = ["CODIGO DA UF", "NOME DA UF", "DEPENDENCIA ADMINISTRATIVA"]

# Adiciona a coluna de dados selecionada ao final
colunas_tabela.append(coluna_dados)

# Verifica se todas as colunas estÃ£o presentes no DataFrame filtrado
colunas_existentes = [col for col in colunas_tabela if col in df_filtrado.columns]
if set(colunas_existentes) != set(colunas_tabela):
    st.warning(f"Algumas colunas nÃ£o estÃ£o disponÃ­veis para exibiÃ§Ã£o na tabela: {set(colunas_tabela) - set(colunas_existentes)}")
    colunas_tabela = colunas_existentes

# Permitir que o usuÃ¡rio selecione colunas adicionais para exibir
todas_colunas = [col for col in df_filtrado.columns if col not in colunas_tabela]
if todas_colunas:
    with st.expander("Selecionar colunas adicionais"):
        colunas_adicionais = st.multiselect(
            "Selecione colunas adicionais para exibir:",
            todas_colunas
        )
        if colunas_adicionais:
            colunas_tabela = colunas_tabela + colunas_adicionais

# Converter a coluna de dados para numÃ©rico para ordenaÃ§Ã£o correta
df_filtrado_tabela = df_filtrado.copy()
if coluna_dados in df_filtrado_tabela.columns:
    # Converter para numÃ©rico para cÃ¡lculos e ordenaÃ§Ã£o
    df_filtrado_tabela[coluna_dados] = pd.to_numeric(df_filtrado_tabela[coluna_dados], errors='coerce')
    
    # Adicionar coluna de percentual
    total = df_filtrado_tabela[coluna_dados].sum()
    if total > 0:
        df_filtrado_tabela['% do Total'] = df_filtrado_tabela[coluna_dados].apply(
            lambda x: (x/total)*100 if pd.notnull(x) else None
        )
        colunas_tabela.append('% do Total')
    
    # Ordenar a tabela pelos valores do coluna_dados em ordem decrescente
    tabela_dados = df_filtrado_tabela[colunas_tabela].sort_values(by=coluna_dados, ascending=False)
    
    # Criar versÃ£o formatada para exibiÃ§Ã£o
    tabela_exibicao = tabela_dados.copy()
    tabela_exibicao[coluna_dados] = tabela_exibicao[coluna_dados].apply(
        lambda x: formatar_numero(x) if pd.notnull(x) else "-"
    )
    
    # Formatar a coluna de percentual se existir
    if '% do Total' in tabela_exibicao.columns:
        tabela_exibicao['% do Total'] = tabela_exibicao['% do Total'].apply(
            lambda x: f"{x:.2f}%" if pd.notnull(x) else "-"
        )
else:
    tabela_dados = df_filtrado_tabela[colunas_existentes]
    tabela_exibicao = tabela_dados.copy()

# Adicionar informaÃ§Ã£o sobre o total de registros
st.info(f"Total de {len(tabela_dados)} registros encontrados.")

# Criar abas para diferentes visualizaÃ§Ãµes
tab1, tab2 = st.tabs(["VisÃ£o Tabular", "Resumo EstatÃ­stico"])

with tab1:
    # OpÃ§Ãµes de paginaÃ§Ã£o primeiro (para saber quantos registros mostrar)
    st.write("### ConfiguraÃ§Ãµes de exibiÃ§Ã£o")
    col1, col2 = st.columns(2)
    
    with col1:
        mostrar_todos = st.checkbox("Mostrar todos os registros", value=False)
    
    with col2:
        if not mostrar_todos:
            registros_por_pagina = st.slider(
                "Registros por pÃ¡gina:", 
                min_value=10, 
                max_value=500, 
                value=100, 
                step=10
            )
        else:
            registros_por_pagina = len(tabela_exibicao)
    
    # Adicionar filtros de busca mais prÃ³ximos da tabela e com largura reduzida
    st.write("### Filtros da tabela")
    
    # Usar colunas com largura reduzida (20% da largura original, ou seja, 10% da tela cada)
    col1, col2, col3, col4 = st.columns([1, 9, 1, 9])
    
    # Filtros para texto (nomes de localidades)
    filtro_texto = None
    colunas_localidade = [col for col in ["NOME DA UF", "NOME DO MUNICIPIO", "NOME DA ESCOLA"] if col in tabela_exibicao.columns]
    if colunas_localidade:
        with col1:
            st.write("**Localidade:**")
        with col2:
            coluna_texto_selecionada = st.selectbox("", ["Nenhum"] + colunas_localidade, label_visibility="collapsed")
            if coluna_texto_selecionada != "Nenhum":
                filtro_texto = st.text_input("", placeholder=f"Filtrar {coluna_texto_selecionada}...", label_visibility="collapsed")
    
    # Filtros para cÃ³digos (numÃ©ricos)
    filtro_codigo = None
    colunas_codigo = [col for col in ["CODIGO DA UF", "CODIGO DO MUNICIPIO", "CODIGO DA ESCOLA"] if col in tabela_exibicao.columns]
    if colunas_codigo:
        with col3:
            st.write("**CÃ³digo:**")
        with col4:
            coluna_codigo_selecionada = st.selectbox(" ", ["Nenhum"] + colunas_codigo, label_visibility="collapsed")
            if coluna_codigo_selecionada != "Nenhum":
                filtro_codigo = st.text_input(" ", placeholder=f"Filtrar {coluna_codigo_selecionada}...", label_visibility="collapsed")
    
    # Aplicar filtros
    tabela_filtrada = tabela_exibicao.copy()
    
    # Filtros em tempo real conforme o usuÃ¡rio digita
    if filtro_texto and coluna_texto_selecionada != "Nenhum":
        # Para nomes, filtra a partir de 3 caracteres
        if len(filtro_texto) >= 3:
            tabela_filtrada = tabela_filtrada[
                tabela_filtrada[coluna_texto_selecionada].astype(str).str.contains(filtro_texto, case=False, na=False)
            ]
    
    if filtro_codigo and coluna_codigo_selecionada != "Nenhum":
        # Para cÃ³digos, filtra a partir do primeiro caractere
        if len(filtro_codigo) >= 1:
            tabela_filtrada = tabela_filtrada[
                tabela_filtrada[coluna_codigo_selecionada].astype(str).str.contains(filtro_codigo, na=False)
            ]
    
    # CÃ¡lculo de paginaÃ§Ã£o
    total_paginas = max(1, (len(tabela_filtrada) - 1) // registros_por_pagina + 1)
    
    if not mostrar_todos and total_paginas > 1:
        pagina_atual = st.number_input(
            "PÃ¡gina:", 
            min_value=1, 
            max_value=total_paginas, 
            value=1
        )
        inicio = (pagina_atual - 1) * registros_por_pagina
        fim = min(inicio + registros_por_pagina, len(tabela_filtrada))
        
        # InformaÃ§Ã£o da paginaÃ§Ã£o
        st.write(f"Exibindo registros {inicio+1} a {fim} de {len(tabela_filtrada)}")
        
        # Exibir apenas os registros da pÃ¡gina atual
        tabela_para_exibir = tabela_filtrada.iloc[inicio:fim]
    else:
        # Exibir todos os registros
        tabela_para_exibir = tabela_filtrada

    # Calcular a soma para a Ãºltima linha de totais
    totais = {}
    if coluna_dados in tabela_para_exibir.columns:
        # Converter para numÃ©rico para cÃ¡lculos corretos
        valores_numericos = pd.to_numeric(tabela_dados[coluna_dados].loc[tabela_para_exibir.index], errors='coerce')
        totais[coluna_dados] = formatar_numero(valores_numericos.sum())
    
    if '% do Total' in tabela_para_exibir.columns:
        totais['% do Total'] = "100.00%"
    
    # Adicionar linha de totais
    linha_totais = pd.DataFrame([totais], index=['TOTAL'])
    
    # Preencher as outras colunas com strings vazias
    for col in tabela_para_exibir.columns:
        if col not in totais:
            linha_totais[col] = ""
    
    # Ordenar as colunas para corresponder Ã  tabela principal
    linha_totais = linha_totais[tabela_para_exibir.columns]
    
    # Combinar a tabela principal com a linha de totais
    tabela_com_totais = pd.concat([tabela_para_exibir, linha_totais])
    
    # Aplicar a centralizaÃ§Ã£o e outros estilos
    def estilizar_tabela(df):
        # Estilo para centralizar todas as cÃ©lulas
        return df.style \
            .set_properties(**{'text-align': 'center'}) \
            .set_table_styles([
                {'selector': 'th', 'props': [('text-align', 'center')]},
                {'selector': 'td', 'props': [('text-align', 'center')]},
                # Destacar a linha de totais
                {'selector': 'tr:last-child', 'props': [
                    ('font-weight', 'bold'),
                    ('background-color', '#f0f0f0')
                ]}
            ])
    
    # Exibir a tabela com altura ajustada para mostrar todos os registros sem rolagem
    altura_tabela = min(len(tabela_com_totais) * 35 + 38, 600)  # 35px por linha + 38px para o cabeÃ§alho, mÃ¡ximo de 600px
    
    # Exibir a tabela sem o Ã­ndice (removendo a primeira coluna)
    tabela_estilizada = estilizar_tabela(tabela_com_totais)
    st.dataframe(tabela_estilizada, use_container_width=True, height=altura_tabela, hide_index=True)
    
    # Mostrar informaÃ§Ã£o atualizada sobre total de registros e matrÃ­culas apÃ³s filtros
    st.markdown(f"""
    <div style="background-color: #f0f0f0; padding: 10px; border-radius: 5px; text-align: center; font-weight: bold;">
        Total apÃ³s filtros: {len(tabela_para_exibir)} registros | {totais[coluna_dados]} matrÃ­culas
    </div>
    """, unsafe_allow_html=True)
    
    # FunÃ§Ãµes para exportar dados
    def converter_df_para_csv(df):
        return df.to_csv(index=False).encode('utf-8')
    
    def converter_df_para_excel(df):
        import io
        output = io.BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            df.to_excel(writer, index=False, sheet_name='Dados')
        return output.getvalue()
    
    # BotÃµes para download
    col1, col2 = st.columns(2)
    
    with col1:
        # Download como CSV
        st.download_button(
            label="Download CSV",
            data=converter_df_para_csv(tabela_dados.loc[tabela_para_exibir.index]),  # Apenas registros exibidos
            file_name=f'dados_{etapa_selecionada.replace(" ", "_")}_{ano_selecionado}.csv',
            mime='text/csv',
        )
    
    with col2:
        # Download como Excel
        st.download_button(
            label="Download Excel",
            data=converter_df_para_excel(tabela_dados.loc[tabela_para_exibir.index]),  # Apenas registros exibidos
            file_name=f'dados_{etapa_selecionada.replace(" ", "_")}_{ano_selecionado}.xlsx',
            mime='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        )

with tab2:
    # Apresentar um resumo estatÃ­stico dos dados
    if coluna_dados in tabela_dados.columns:
        col1, col2 = st.columns(2)
        
        with col1:
            # Tabela de estatÃ­sticas
            resumo = pd.DataFrame({
                'MÃ©trica': ['Total', 'MÃ©dia', 'Mediana', 'MÃ­nimo', 'MÃ¡ximo', 'Desvio PadrÃ£o'],
                'Valor': [
                    formatar_numero(tabela_dados[coluna_dados].sum()),
                    formatar_numero(tabela_dados[coluna_dados].mean()),
                    formatar_numero(tabela_dados[coluna_dados].median()),
                    formatar_numero(tabela_dados[coluna_dados].min()),
                    formatar_numero(tabela_dados[coluna_dados].max()),
                    formatar_numero(tabela_dados[coluna_dados].std())
                ]
            })
            st.write("### Resumo EstatÃ­stico")
            
            # Estilizar a tabela de resumo
            resumo_estilizado = resumo.style.set_properties(**{'text-align': 'center'}) \
                .set_table_styles([{'selector': 'th', 'props': [('text-align', 'center')]}])
            
            st.dataframe(resumo_estilizado, use_container_width=True, hide_index=True)
        
        with col2:
            # Top 5 valores
            st.write("### Top 5 Valores")
            top5 = tabela_dados.nlargest(5, coluna_dados)
            
            # Selecionar colunas para exibiÃ§Ã£o
            colunas_exibir = []
            if tipo_visualizacao == "Escola" and "NOME DA ESCOLA" in top5.columns:
                colunas_exibir.append("NOME DA ESCOLA")
            elif tipo_visualizacao == "MunicÃ­pio" and "NOME DO MUNICIPIO" in top5.columns:
                colunas_exibir.append("NOME DO MUNICIPIO")
            elif "NOME DA UF" in top5.columns:
                colunas_exibir.append("NOME DA UF")
            
            if "DEPENDENCIA ADMINISTRATIVA" in top5.columns:
                colunas_exibir.append("DEPENDENCIA ADMINISTRATIVA")
                
            colunas_exibir.append(coluna_dados)
            if '% do Total' in top5.columns:
                colunas_exibir.append('% do Total')
            
            # Formatar valores para exibiÃ§Ã£o
            top5_exibir = top5[colunas_exibir].copy()
            if coluna_dados in top5_exibir.columns:
                top5_exibir[coluna_dados] = top5_exibir[coluna_dados].apply(
                    lambda x: formatar_numero(x) if pd.notnull(x) else "-"
                )
            
            if '% do Total' in top5_exibir.columns:
                top5_exibir['% do Total'] = top5_exibir['% do Total'].apply(
                    lambda x: f"{x:.2f}%" if pd.notnull(x) else "-"
                )
                
            # Estilizar a tabela top5
            top5_estilizado = top5_exibir.style.set_properties(**{'text-align': 'center'}) \
                .set_table_styles([{'selector': 'th', 'props': [('text-align', 'center')]}])
            
            st.dataframe(top5_estilizado, use_container_width=True, hide_index=True)

# -------------------------------
# RodapÃ© do Dashboard
# -------------------------------
st.markdown("---")
st.markdown("**Nota:** Os dados sÃ£o provenientes do Censo Escolar. Os traÃ§os (-) indicam ausÃªncia de dados.")
